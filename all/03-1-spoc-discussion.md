# lec5: SPOC思考题

##**提前准备**
（请在上课前完成）

- 完成lec５的视频学习和提交对应的在线练习
- git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises in github repos。这样可以在本机上完成课堂练习。
- 理解连续内存动态分配算法的实现（主要自学和网上查找）

NOTICE
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。


## 思考题
---

## “连续内存分配”与视频相关的课堂练习

### 5.1 计算机体系结构和内存层次

1.操作系统中存储管理的目标是什么？

我认为存储管理的目标是更好地为程序运行提供支持。

为了提高主频，加快程序运行的速度，设计了寄存器-cache-内存-外存的多级存储架构。

为了使应用程序能运行在不同的系统环境中，引入了虚拟内存的概念，将软件和硬件解耦。

通过保护和共享机制，更好地处理不同进程之间的内存访问，允许合理的共享内存访问，防止非法访问。

通过分段分页机制，将程序使用的内存空间细分，更加充分地利用了内存。


### 5.2 地址空间和地址生成
1.描述编译、汇编、链接和加载的过程是什么？

编译的过程是将高级语言的程序翻译成汇编语言表述的程序，此时地址可以由变量来表示。

链接是将多个程序静态连接形成完整的程序。

加载是在执行时将程序加载到内存中，并开始执行。



2.动态链接如何使用？尝试在Linux平台上使用LD_DEBUG查看一个C语言Hello world的启动流程。  (optional)

以gcc为例，在编译时使用**-l**指令即可调用动态库。

### 5.3 连续内存分配
1.什么是内碎片、外碎片？

内碎片是分给一个进程的内存片中没有被使用的，出现的原因是进程使用的内存不是整数倍的。

外碎片是进程内存分片之间的碎片区域，出现的原因是之前使用该内存的进程被释放了。



2.最先匹配会越用越慢吗？请说明理由（可来源于猜想或具体的实验）？

会越用越慢，因为在使用的过程中，内存空间会被切分得越来越细，导致外碎片数量增加。当一个新的进程需要申请内存时，大量的外碎片都是无法使用的，查询的时间会越来越长。



3.最差匹配的外碎片会比最优适配算法少吗？请说明理由（可来源于猜想或具体的实验）？

在内存分配不紧张时，外碎片会少，因为最差匹配有限分配大空闲分区，而大分区可以多次使用，不容易造成碎片。在内存分配资源较为紧张时，二者差别不大。



4.理解0:最优匹配，1:最差匹配，2:最先匹配，3:buddy systemm算法中分区释放后的合并处理过程？ (optional)

最差匹配和最优匹配，分区释放后需要和附近分区合并，重新放入空闲分区表。

最先匹配只需和邻近分区合并，无额外操作。




### 5.4 碎片整理
1.对换和紧凑都是碎片整理技术，它们的主要区别是什么？为什么在早期的操作系统中采用对换技术？

对换技术的原理是将处于空闲状态的进程存入外存中，将释放的内存空间交给执行中的进程使用；

紧凑技术则是通过整理外碎片的方式，使空闲内存分区更为完整，方便分配给新加入的进程使用。

早期的操作系统通过使用对换技术，实现了简单的多任务操作系统。



2.一个处于等待状态的进程被对换到外存（对换等待状态）后，等待事件出现了。操作系统需要如何响应？

操作系统需要讲该进程和内存中另一个处于等待状态的进程对换，重新将它放入内存中，继续响应事件。



### 5.5 伙伴系统
1.伙伴系统的空闲块如何组织？

如果大小相同并且属于同一分支，则可以合并得到更大的空闲块。



2.伙伴系统的内存分配流程？伙伴系统的内存回收流程？

分配流程：每当一个新的进程申请内存时，伙伴系统先从小到大找到第一块大于它的空闲块，接着将空闲块连续二分直至恰好满足进程的需求，接着将改空闲块分配给进程，剩余的块放入空闲块列表中。

回收流程：当有进程结束运行时，伙伴系统将空闲块回收，查看空闲块是否可以和相邻的空闲块合并。接着将它放入空闲块列表中。

## 课堂实践

观察最先匹配、最佳匹配和最差匹配这几种动态分区分配算法的工作过程，并选择一个例子进行分析分析整个工作过程中的分配和释放操作对维护数据结构的影响和原因。

  * [算法演示脚本的使用说明](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep3-malloc.md)
  * [算法演示脚本](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep3-malloc.py)

例如：

补充：是python2的代码，跑不了啊……

```
python ./ostep3-malloc.py -S 100 -b 1000 -H 4 -a 4 -l ADDRSORT -p BEST -n 5 -c
python ./ostep3-malloc.py -S 100 -b 1000 -H 4 -a 4 -l ADDRSORT -p FIRST -n 5 -c
python ./ostep3-malloc.py -S 100 -b 1000 -H 4 -a 4 -l ADDRSORT -p WORST -n 5 -c
```

### 扩展思考题 (optional)

1. 请参考xv6（umalloc.c），ucore lab2代码，选择四种（0:最优匹配，1:最差匹配，2:最先匹配，3:buddy systemm）分配算法中的一种或多种，在Linux应用程序/库层面，用C、C++或python来实现malloc/free，给出你的设计思路，并给出可以在Linux上运行的malloc/free实现和测试用例。


2. 阅读[slab分配算法](http://en.wikipedia.org/wiki/Slab_allocation)，尝试在应用程序中实现slab分配算法，给出设计方案和测试用例。
