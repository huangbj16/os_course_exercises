# lec4: lab1 SPOC思考题

##**提前准备**
（请在上课前完成）

 - 完成lec4的视频学习和提交对应的在线练习
 - git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises in github repos。这样可以在本机上完成课堂练习。
 - 了解x86的保护模式，段选择子，全局描述符，全局描述符表，中断描述符表等概念，以及如何读写，设置等操作
 - 了解Linux中的ELF执行文件格式
 - 了解外设:串口，并口，时钟，键盘,CGA，已经如何对这些外设进行编程
 - 了解x86架构中的mem地址空间和io地址空间
 - 了解x86的中断处理过程（包括硬件部分和软件部分）
 - 了解GCC的x86/RV内联汇编
 - 了解C语言的可函数变参数编程
 - 了解qemu的启动参数的含义
 - 在piazza上就lec3学习中不理解问题进行提问
 - 学会使用 qemu
 - 在linux系统中，看看 /proc/cpuinfo的内容

## 思考题

### 启动顺序

1. x86段寄存器的字段含义和功能有哪些？

   代码段寄存器CS（Code Segment）

   - 存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的[存储器](https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8)段中取得，相应的偏移量则由IP提供。

   数据段寄存器DS（Data Segment）

   - 指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址。

   堆栈段寄存器SS（Stack Segment）

   - 指出当前堆栈的底部地址，即存放堆栈段的段基址。

   附加段寄存器ES（Extra Segment）

   - 指出当前程序使用附加[数据段](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%AE%B5)的段基址，该段是串操作指令中目的串所在的段。

   此处顺便总结了一下视频中提到的其它寄存器。

   | 寄存器     | 值        | 含义        |
   | ---------- | --------- | ----------- |
   | CS         | F000H     | 起始地址    |
   | EIP        | FFF0H     | 起始地址    |
   | CR0        | 0x0->0x1  | 模式标志    |
   | EFLAGS     | 00000002H | 标志位      |
   | 通用寄存器 | 0         | 初值赋值为0 |

2. x86描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？

   **CPL(Current Privilege Level)**

   CPL是当前执行的任务的特权等级，它存储在CS和SS的第0位和第1位上。(两位表示0~3四个等级)

   通常情况下，CPL等于代码所在段的特权等级，当程序转移到不同的代码段时，处理器将改变CPL。

   **DPL(Descriptor Privilege Level)**

   表示门或者段的特权级，存储在门（中断描述符IDT）或者段的描述符（GDT）的DPL字段中。正如上面说的那样，当当前代码段试图访问一个段或者门时，其DPL将会和当前特权级CPL以及段或门的选择子比较，根据段或者门的类型不同，DPL的含义不同：

   **RPL（Rquest Privilege Level）**

   RPL是通过选择子的低两位来表现出来的(这么说来，CS和SS也是存放选择子的，同时CPL存放在CS和SS的低两位上，那么对CS和SS来说，选择子的RPL=当前段的CPL)。处理器通过检查RPL和CPL来确认一个访问是否合法。即提出访问的段除了有足够的特权级CPL，如果RPL不够也是不行的(有些情况会忽略RPL检查)。

3. 分析可执行文件格式elf的格式（无需回答）

   每个elf文件的头部有一段对文件的描述，称为elf header；通过读取elf header中的phoff和phnum，可以得到program header的地址，进而读取program header的内容，得知program size和virtual address。

### 4.1 C函数调用的实现

### 4.2 x86中断处理过程

1. x86/RV中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？

   x86出现异常中断后，系统根据中断好首先查询IDT，得到段选择子，再使用段选择子从GDT中查询得到中断服务例程的起始地址。

   如果是在内核态，则不产生特权级变化。存储Error code，EIP，CS和EFLAGS，修改ESP。

   如果是在用户态，则产生特权级变化。除了将上述四个值压如内核态的栈之外，还需压如用户栈的ESP和SS，以便中断处理结束之后返回用户态继续执行。

2. 为什么在用户态的中断响应要使用内核堆栈？

   用户态出现中断需要切换到内核态处理，自然要用内核态的堆栈来存储系统状态。

3. x86中trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?

   调用Interrupt Gate时，Interrupt会被CPU自动禁止；调用Trap Gate时，CPU则不会去禁止或打开中断，而是保留它原来的样子；如果在设置上不做区分，会导致重复触发中断。

### 4.3 练习四和五 ucore内核映像加载和函数调用栈分析

1. ucore中，在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？

   ebp可以直接获得，若不内联，则会因为函数调用对栈的修改而得到错误的ebp值。而由于没有直接获取eip值的指令，我们需要利用call指令将eip压栈的特性，通过调用read_eip函数来读出压在栈上的eip的值。若将read_eip内联，则不会有函数调用存在，无法获得eip的值。

### 4.4 练习六 完善中断初始化和处理

1. CPU加电初始化后中断是使能的吗？为什么？

   不是使能的，此时GDT还未建立好，CPU是不支持中断的，所以中断使能应该为0.

## 开放思考题

1. 在ucore/rcore中如何修改lab1, 实现在出现除零异常时显示一个字符串的异常服务例程？
2. 在ucore lab1/bin目录下，通过`objcopy -O binary kernel kernel.bin`可以把elf格式的ucore kernel转变成体积更小巧的binary格式的ucore kernel。为此，需要如何修改lab1的bootloader, 能够实现正确加载binary格式的ucore OS？ (hard)
3. GRUB是一个通用的x86 bootloader，被用于加载多种操作系统。如果放弃lab1的bootloader，采用GRUB来加载ucore OS，请问需要如何修改lab1, 能够实现此需求？ (hard)
4. 如果没有中断，操作系统设计会有哪些问题或困难？在这种情况下，能否完成对外设驱动和对进程的切换等操作系统核心功能？

## 课堂实践
### 练习一
在Linux系统的应用程序中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。

### 练习二
在ucore/rcore内核中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。
